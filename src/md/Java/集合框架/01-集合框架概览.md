---
title: 01-集合框架概览
---
---
title: 01-集合框架概览
---

## 1.Java 的万物之容：容器

如果我们将 Java 程序比作一个超市，那么容器就像是其中的货架和篮子，可以放置各种物品。而 Java Collections Framework (JCF) 就像是我们的 “智能货架系统”，它自 JDK 1.2 起就一直为开发者们提供服务。

那么，它的优势在哪里呢？

* **省时 & 易用**：大大降低了编程难度，使开发更迅速。
* **性能优化**：为程序提供了更出色的运行效率。
* **学习简便**：让新手更快上手，提高学习的效率。
* **代码复用**：允许程序在多个地方更容易地重复使用代码。

当我们说到 Java 容器，你可能需要注意的是：这些容器里只喜欢存放对象。对于基本数据类型，如 int 或 long，它们需要被转化为它们的对象表现形式，比如 Integer 或 Long，才能被 “收纳”。但别担心，大多数时候这种转变都是自动完成的。虽然这样可能会增加一点性能和存储的开销，但这也极大简化了我们的编程工作。

简单来说，这些容器可以分为两大家族：`Collection` 和 `Map`。`Collection` 是那些存储对象集合的 “货架”，而 `Map` 则像是一个标签明确的 “存储柜”，其中每个物品（值）都有一个与之对应的标签（键）。

## 2.Collection 家族

### 2.1 Set：独一无二的集合

想象一下，你正在筹办一个派对，而 `Set` 接口的实现就像是你的宾客名单，确保每个人只被邀请一次，防止重复。在这里，我们会探讨三种常见的 `Set` 实现。

| 实现          | 数据结构        | 描述                                                         |
| ------------- | --------------- | ------------------------------------------------------------ |
| HashSet       | 哈希表          | 如果你需要迅速查找，这是个好选择。但它并不保留插入的顺序，因此如果你想知道谁首先到达派对，那么这可能不是最佳选择。遍历它得到的结果是不确定的。 |
| TreeSet       | 红黑树          | 当你需要有序的邀请名单时，选择它。例如，你可能想要按年龄或姓名对宾客进行排序。但在速度方面，它的查找效率不如 HashSet。 |
| LinkedHashSet | 哈希表 + 双链表 | 当你想要速度和顺序的完美结合时，这是最佳选择。它维护了元素的插入顺序，这意味着你可以知道谁首先到达，同时还享有高效的查找速度。 |

> HashSet 是基于哈希表的，所以它的查找和插入效率非常高，通常为 O(1)。而 TreeSet 是基于红黑树的，它的查找和插入效率为 O(logN)。LinkedHashSet 则结合了哈希表的速度和链表的有序性。

### 2.2 List：你的日常购物清单

当我们去购物时，我们可能会列一个购物清单。这个清单上的物品有其特定的顺序。`List` 接口的实现就像是我们的这个购物清单，可以存放重复的元素并保持它们的插入顺序。

| 实现       | 数据结构 | 描述                                                         |
| ---------- | -------- | ------------------------------------------------------------ |
| ArrayList  | 动态数组 | 像是我们的购物清单的草稿，它支持随机访问，这使得你可以快速查找购物清单上的任何物品。 |
| Vector     | 动态数组 | 想象一下你与家人共同维护的购物清单，Vector 是线程安全的，所以你们可以同时编辑它。 |
| LinkedList | 双向链表 | 如果你经常更改购物清单的顺序或在中间添加和删除物品，这是个好选择，它还可以用作栈、队列和双向队列。 |

> 动态数组如 ArrayList 和 Vector 能够很好地支持随机访问，但它们在中间插入和删除元素时可能不如 LinkedList 高效。

### 2.3 Queue：排队购票

当我们在购票点或快餐店排队时，队列是我们必须遵守的规则，先来先得。`Queue` 接口的实现确保了这一点，并提供了其他的功能。

| 实现          | 数据结构 | 描述                                                         |
| ------------- | -------- | ------------------------------------------------------------ |
| LinkedList    | 双向链表 | 如果你在找一个简单的双向队列，这是你的首选。它是 List 的一部分，但也很适合作为队列使用。 |
| PriorityQueue | 堆       | 这就像是 VIP 通道。当你想确保某些元素（比如 VIP）优先被处理，而不仅仅是他们到达的顺序，那么你应该选择 PriorityQueue。 |

## 3.Map：从宝藏地图到导航

想象一下，我们每天都在用地图 — 从宝藏地图的神秘探索，到使用导航在城市间穿梭。在编程世界中，`Map` 接口允许我们存储键值对，就像是地点和它的说明。让我们看看 Java 为我们提供的各种 “地图”。

| 实现          | 数据结构          | 描述                                                         |
| ------------- | ----------------- | ------------------------------------------------------------ |
| HashMap       | 哈希表            | 就像是你的简单的宝藏地图，你可以快速找到任何地点和它的宝藏，但是没有固定的顺序。 |
| HashTable     | 哈希表            | 这是一张古老的宝藏地图，虽然它支持多个探险家同时查看，但现代工具，如ConcurrentHashMap，为我们提供了更好和更高效的线程安全性。 |
| LinkedHashMap | 哈希表 + 双向链表 | 当你既想找到宝藏，又想记住你的旅程（插入顺序或最近查看的宝藏地点），这是你的选择。 |
| TreeMap       | 红黑树            | 这是一张精致的地图，它不仅按照某种顺序（例如地点的名称）整齐地显示所有地点，还允许你快速查找任何区域的宝藏。 |

> 尽管 HashMap 可以快速查找，但如果我们需要有序性，例如最小到最大的键值对，TreeMap 是更好的选择。

## 4.知识体系

![](https://javgo-images.oss-cn-beijing.aliyuncs.com/2023-09-28-153426.png)