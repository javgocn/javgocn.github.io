---
title: 排序-冒泡排序（Bubble_sort）
---
## 1.概述
冒泡排序（Bubble sort），有时也被称为下沉排序（sinking sort），是一种简单的排序算法。它通过反复遍历输入列表，逐个元素地比较当前元素与其后面的元素，并在需要时交换它们的值。这种遍历列表的操作会重复进行，直到在一次完整的遍历中没有进行任何交换为止，这意味着列表已经完全排序了。这种比较排序算法之所以被命名为 “冒泡排序”，是因为较大的元素会像 “气泡” 一样逐渐上浮到列表的顶部。

尽管冒泡排序在概念上很简单，但在实际应用中，其性能并不理想，主要作为教育工具使用。更高效的算法，如快速排序、timsort 或归并排序，被集成到了如 Python 和 Java 等流行编程语言的排序库中。

然而，如果允许并行处理，冒泡排序的时间复杂度可以达到 **_O_** (n)，这使得它在并行实现上比插入排序或选择排序更为高效，因为后两者在并行化方面并不如冒泡排序有效。

下面是一个冒泡排序的例子：

![](https://javgo-images.oss-cn-beijing.aliyuncs.com/2023-08-31-033713.gif)

从列表的开头开始，比较每个相邻的对，如果顺序不对，交换它们的位置(后一个比前一个小)。每次迭代之后，需要比较的元素会减少一个（最后一个已经是最大元素无需参与下一轮比较)，直到没有更多的元素需要比较为止。

| 最坏表现 | 比较：*O*  ( n2 )<br/>交换：*O*  ( n2 ) |
| --- | --- |
| 最优表现 | 比较：*O*  ( n )<br/>交换：*O*  ( 1 ) |
| 平均表现 | 比较：*O*  ( n2 )<br/>交换：*O*  ( n2 ) |
| 空间复杂度 | 总计：*O*  ( n )<br/>辅助：*O*  ( 1 ) |

## 2.性能分析
### 2.1 性能表现
冒泡排序在最坏情况和平均情况下的时间复杂度都是 **_O_** (n2)，其中 n 是待排序项的数量。大多数实用的排序算法都有更好的最坏情况或平均情况的时间复杂度，通常是 **_O_** (nlogn)。即使是其他 **_O_** (n2) 的排序算法，如插入排序，通常也比冒泡排序运行得更快，并且它们的复杂性并不更高。因此，冒泡排序在实际中很少使用。

与插入排序一样，冒泡排序是自适应的，这使得它相对于像快速排序这样的算法具有优势。这意味着，在列表已经大部分排序的情况下（即只有少量的逆序对），尽管冒泡排序的平均时间复杂度较差，但它可能会比那些算法（如快速排序）表现得更好。例如，对于一个已经排序的列表，冒泡排序的时间复杂度是 **_O_** (n)，而快速排序仍然会执行其完整的 **_O_** (nlogn) 排序过程。

尽管任何排序算法在预先排序的列表上都可以通过在算法运行之前检查列表来达到 **_O_** (n) 的时间复杂度，但在几乎已排序的列表上提高性能是更难以实现的。

### 2.2 元素移动
在冒泡排序中，元素需要移动的距离和方向决定了其性能，因为不同的元素以不同的速度向不同的方向移动。

1. **兔子（Rabbits）**：需要向列表末尾移动的元素可以快速移动，因为它可以连续参与多次交换。例如，列表中最大的元素会在每次比较中都是较大的，因此即使它最初位于列表的开始位置，它也会在第一次遍历中移动到其排序后的位置。这种元素被称为 “兔子”。
2. **乌龟（Turtles）**：另一方面，需要向列表开始位置移动的元素每次只能移动一步，因此这些元素向开始位置的移动速度非常慢。如果最小的元素位于列表的末尾，那么它需要进行 n-1 次遍历才能移动到开始位置。这种元素被称为 “乌龟”。

这种元素移动的特性来源于伊索寓言中的故事《龟兔赛跑》，其中兔子移动得很快，而乌龟移动得很慢。

为了提高冒泡排序的速度，人们做了各种尝试来消除 “乌龟” 元素的影响：

- **鸡尾酒排序（Cocktail sort）**：这是一个双向的冒泡排序，它从开始到结束进行排序，然后反向从结束到开始。这种方法可以相对有效地移动 “乌龟” 元素，但它仍然保持 **_O _**(n2) 的最坏情况时间复杂度。
- **梳排序（Comb sort）**：这种排序方法通过比较相隔较大距离的元素来进行排序，这样可以非常快速地移动 “乌龟” 元素。随后，它会逐渐减小这个距离，使列表变得更加平滑。其平均速度与像快速排序这样的更快的算法相当。
### 2.3 逐步示例
让我们使用冒泡排序为一个数字数组 [5 ,1 ,4 ,2 ,8] 进行排序，从最小数到最大数。在每一步中，粗体的元素正在被比较。整个过程需要三轮遍历：

**第一轮遍历：**

( **5 1** 4 2 8 ) → ( **1 5** 4 2 8 )：算法比较前两个元素，并因为 5 > 1 而交换它们

( 1 **5 4** 2 8 ) → ( 1 **4 5** 2 8 )：因为 5 > 4，所以交换

( 1 4 **5 2** 8 ) → ( 1 4 **2 5** 8 )：因为 5 > 2，所以交换

( 1 4 2 **5 8** ) → ( 1 4 2 **5 8** )：这两个元素已经是有序的（8 > 5），不交换

**第二轮遍历：**

( **1 4** 2 5 8 ) → ( **1 4** 2 5 8 )：元素已经是有序的，不需要交换

( 1 **4 2** 5 8 ) → ( 1 **2 4** 5 8 )：因为 4 > 2，所以交换

( 1 2 **4 5** 8 ) → ( 1 2 **4 5** 8 )：元素已经是有序的，不需要交换

( 1 2 4 **5 8** ) → ( 1 2 4 **5 8** )：元素已经是有序的，不需要交换

此时，数组已经排序完毕，但算法并不知道它已经完成。为了确认数组已经排序，算法需要再进行一次完整的遍历，如果这次遍历中没有任何交换操作，那么算法就知道数组已经排序。

**第三轮遍历：**

( **1 2** 4 5 8 ) → ( **1 2** 4 5 8 )：元素已经是有序的，不需要交换

( 1 **2 4** 5 8 ) → ( 1 **2 4** 5 8 )：元素已经是有序的，不需要交换

( 1 2 **4 5** 8 ) → ( 1 2 **4 5** 8 )：元素已经是有序的，不需要交换

( 1 2 4 **5 8** ) → ( 1 2 4 **5 8** )：元素已经是有序的，不需要交换

在第三轮遍历中，没有任何交换操作，所以算法确认数组已经排序，并结束排序过程。

## 3.代码实现
### 3.1 基本实现
这个算法通过重复遍历列表来工作，比较每对相邻的元素，并交换它们（如果它们是错序的）。每次遍历后，最大的元素都会 “冒泡” 到它应该在的位置。

```java
/**
 * 冒泡排序：基本实现
 */
public class BubbleSort01 {

    /**
     * 冒泡排序
     * @param arr 待排序数组
     */
    public static void bubbleSort(int[] arr){
        // 记录数组长度
        int len = arr.length;
        // 记录是否发生了交换
        boolean swapped;

        do {
            // 假设没有发生交换
            swapped = false;
            // 遍历数组
            for (int i = 1; i < len; i++) {
                // 如果前一个元素大于后一个元素
                if (arr[i -1] > arr[i]){
                    // 交换两个元素
                    int temp = arr[i - 1];
                    arr[i - 1] = arr[i];
                    arr[i] = temp;

                    // 发生了交换
                    swapped = true;
                }
            }
        }while (swapped);   // 如果发生了交换，说明数组还没有排好序，需要继续循环
    }

    public static void main(String[] args) {
        int[] arr = {5,8,6,3,9,2,1,7};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

### 3.2 优化：不比较每次遍历出现的最大元素
考虑到在每次遍历后，最大的元素都会被放在正确的位置，所以我们可以减少遍历的长度。例如，第一次遍历后，最大的元素已经在最后的位置，所以第二次遍历只需要到倒数第二个位置。

```java
/**
 * 冒泡排序：不比较每次遍历出现的最大元素
 */
public class BubbleSort02 {

    /**
     * 冒泡排序
     * @param arr 待排序数组
     */
    public static void bubbleSort(int[] arr){
        // 记录数组长度
        int len = arr.length;
        // 记录是否发生了交换
        boolean swapped;

        do {
            // 假设没有发生交换
            swapped = false;
            // 遍历数组
            for (int i = 1; i < len; i++) {
                // 如果前一个元素大于后一个元素
                if (arr[i -1] > arr[i]){
                    // 交换两个元素
                    int temp = arr[i - 1];
                    arr[i - 1] = arr[i];
                    arr[i] = temp;

                    // 发生了交换
                    swapped = true;
                }
            }
            // 由于每次遍历都会将最大的元素放到最后，所以下一次遍历的时候，最后一个元素可以不用比较
            len--;
        }while (swapped);   // 如果发生了交换，说明数组还没有排好序，需要继续循环
    }

    public static void main(String[] args) {
        int[] arr = {5,8,6,3,9,2,1,7};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

### 3.3 优化：最大化减少遍历次数
这个版本考虑到在一次遍历中可能有多个元素被放在了它们最终的位置。因此，我们可以跟踪最后一次交换的位置，然后在下一次遍历时只遍历到这个位置，因为之后的元素已经排序完成。
```java
/**
 * 冒泡排序：最大化减少遍历次数
 */
public class BubbleSort03 {

    /**
     * 冒泡排序
     * @param arr 待排序数组
     */
    public static void bubbleSort(int[] arr){
        // 记录数组长度
        int len = arr.length;
        // 记录最后一次交换的位置
        int lastSwappedIndex;

        do {
            // 假设没有发生交换，即数组已经排好序了，此时最后一次交换的位置为 0
            lastSwappedIndex = 0;
            
            // 遍历数组
            for (int i = 1; i < len; i++) {
                // 如果前一个元素大于后一个元素
                if (arr[i - 1] > arr[i]){
                    // 交换两个元素
                    int temp = arr[i - 1];
                    arr[i - 1] = arr[i];
                    arr[i] = temp;

                    // 发生了交换，记录最后一次交换的位置
                    lastSwappedIndex = i;
                }
            }

            // 下一次遍历只需要遍历到最后一次交换的位置即可，因为后面的元素已经排好序了
            len = lastSwappedIndex;
        }while (len > 1); // 如果数组长度为1，说明已经排好序了，不需要再遍历了
    }

    public static void main(String[] args) {
        int[] arr = {5,8,6,3,9,2,1,7};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```
## 4.使用注意事项
冒泡排序是最容易理解和实现的排序算法之一，但其 **_O_** (n2) 的复杂度意味着在元素数量较多的列表上，其效率会急剧下降。即使在简单的 _**O**_ (n2) 排序算法中，像插入排序这样的算法通常也要比冒泡排序高效得多。

由于其简单性，冒泡排序经常被用来向计算机科学初学者介绍算法或排序算法的概念。然而，一些研究人员，如 Owen Astrachan，已经付出了巨大的努力来贬低冒泡排序在计算机科学教育中的持续受欢迎程度，建议不再教授它。

Jargon File 称 bogosort 为 "典型的糟糕算法"，也称冒泡排序为 "通用的糟糕算法"。Donald Knuth 在《计算机程序设计艺术》中总结说，"冒泡排序似乎除了一个朗朗上口的名字和它引出的一些有趣的理论问题外，没有其他推荐之处"。

冒泡排序在最坏的情况下与插入排序在运行时间上是渐近等价的，但这两种算法在必要的交换次数上有很大的不同。Astrachan 的实验结果也显示，即使在随机列表上，插入排序的表现也要好得多。

由于这些原因，许多现代算法教科书都避免使用冒泡排序，而更喜欢插入排序。

冒泡排序与现代 CPU 硬件的交互也不佳。与插入排序相比，它至少产生两倍的写操作，两倍的缓存未命中，以及渐近更多的分支预测错误。Astrachan 在 Java 中对字符串进行排序的实验显示，冒泡排序的速度大约只有插入排序的五分之一，选择排序的 70%。

然而冒泡排序也并非一无是处，在某些特定场景，如计算机图形学中，冒泡排序因其稳定性和对近乎排序数据的高效处理而受到欢迎。但总体而言，鉴于其性能问题，许多现代算法书籍和实践中都倾向于使用如插入排序这样的更高效算法。

---

TIP：参考资料

- [https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)
