---
title: 排序-选择排序（Selection_sort）
---
## 1.概述
选择排序是计算机科学中的一种原地比较排序算法。它的时间复杂度为 **_O_** (n2)，这使得它在处理大量数据列表时效率不高，并且通常比类似的插入排序性能差。尽管如此，选择排序因其简单性而受到关注，并且在某些特定情况下，特别是在辅助内存有限的情况下，它相对于更复杂的算法具有性能优势。

该算法将输入列表分为两部分：一个从左到右建立的已排序子列表，位于列表的前部（左侧），以及一个剩余的未排序子列表。最初，已排序的子列表是空的，而未排序的子列表是整个输入列表。算法通过找到未排序子列表中的最小（或最大，取决于排序顺序）元素，与最左侧的未排序元素交换（将其排序），然后将子列表的边界向右移动一个元素来进行。

| 最差表现 | - 比较：**_O_** (n2)<br />- 交换：**_O_** (n) |
| --- | --- |
| 最优表现 | - 比较：**_O_** (n2)<br />- 交换：**_O_** (1) |
| 平均表现 | - 比较：**_O_** (n2)<br />- 交换：**_O_** (n) |
| 空间复杂度 | - 辅助：**_O_** (1) |

以下是此排序算法对五个元素进行排序的示例：

| **已排序子列表** | **未排序子列表** | **未排序列表中的最小元素** |
| --- | --- | --- |
| () | (11, 25, 12, 22, 64) | 11 |
| (11) | (25, 12, 22, 64) | 12 |
| (11, 12) | (25, 22, 64) | 22 |
| (11, 12, 22) | (25, 64) | 25 |
| (11, 12, 22, 25) | (64) | 64 |
| (11, 12, 22, 25, 64) | () |  |

> [!TIP]
>
> 在最后两行上没有任何变化，因为最后两个数字已经按顺序排列。

选择排序也可以用于想要使添加和删除操作高效的列表结构，例如链表。在这种情况下，更常见的做法是从列表的其余部分中删除最小元素，然后将其插入到迄今为止已排序的值的末尾。例如：
```java
arr[] = 64 25 12 22 11

// 在 arr[0...4] 中找到最小的元素
// 并将其放在开始位置
11 25 12 22 64

// 在arr[1...4]中找到最小的元素
// 并将其放在arr[1...4]的开始位置
11 12 25 22 64

// 在arr[2...4]中找到最小的元素
// 并将其放在arr[2...4]的开始位置
11 12 22 25 64

// 在arr[3...4]中找到最小的元素
// 并将其放在arr[3...4]的开始位置
11 12 22 25 64
```
下面是一个选择排序的动图示例：（红色：当前最小值     黄色：排序列表     蓝色：当前项目）

![](https://javgo-images.oss-cn-beijing.aliyuncs.com/2023-08-31-035245.gif)

可以看出，选择排序是一个简单的排序算法，它通过不断地选择剩余部分中的最小（或最大)元素来工作。尽管它在大型数据集上不是最高效的，但其简单性使其在某些情况下仍然有用。

## 2.代码实现
实现步骤如下：

1. **初始化外部循环**：遍历整个数组，但可以排除最后一个元素，因为当其余元素都已排序时，最后一个元素自然也就排序了。
2. **假设最小值**：对于每个外部循环的迭代，首先假设当前索引的元素是最小的。
3. **查找最小值**：使用内部循环从当前索引的下一个元素开始，查找整个数组的其余部分以找到实际的最小元素。
4. **交换元素**：如果找到的最小元素的索引不是当前外部循环的索引，则将它们交换。

这种方法确保在每次外部循环迭代后，最小的未排序元素都会被放置在其正确的位置。
```java
/**
 * 选择排序
 */
public class SelectionSort01 {

    /**
     * 选择排序
     * @param arr 待排序数组
     */
    public static void selectionSort(int[] arr){
        // 记录数组长度
        int len = arr.length;

        // 初始化外部循环，用于记录当前已排序的元素个数
        // 最后一个元素不需要遍历，因为它会和倒数第二个元素比较，如果倒数第二个元素比它小，就会交换，这样最后一个元素就是最大的
        for (int i = 0; i < len - 1; i++) {
            // 假设最小值：对每一轮排序，都假设当前未排序的第一个元素是最小值
            int min = i;

            // 初始化内部循环，用于遍历未排序的元素
            // 从当前索引的下一个元素开始遍历寻找实际的最小值，因为当前索引之前的元素都是已经排序好的
            for (int j = i + 1; j < len; j++) {
                // 查找实际最小值：如果当前元素比假设的最小值还要小，就更新最小值的索引
                if(arr[j] < arr[min]){
                    min = j;
                }
            }

            // 交换元素：如果假设的最小值和实际的最小值不是同一个元素，就交换它们
            if(min != i){
                int temp = arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {5,2,4,6,1,3};
        selectionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```
