---
title: 排序-插入排序（Insertion_sort）
---
## 1.概述
插入排序是一种基本的排序方法，通过逐项比较来逐步构建排序后的数组或列表。尽管它在处理大量数据时不如快速排序、堆排序或归并排序等高级算法高效，但插入排序仍具有以下优势：

- **简洁性**：例如，Jon Bentley 展示了一个简洁的 C/C++ 实现，仅三行代码，经过优化后为五行。
- **小数据效率**：对于小规模数据，其效率与其他 **_O_** (n2) 的排序算法相当。
- **实际效果**：与选择排序或冒泡排序等其他简单算法相比，插入排序在实际应用中更为高效。
- **适应性**：特别适合那些已经部分排序的数据集，例如，当每个元素距离其应在的位置不超过 k 时，其时间复杂度为 **_O_** (kn)。
- **稳定性**：它保持了具有相同值的元素之间的原始顺序，而不像快速排序那样可能发生交换而破坏原始数据。
- **原地排序**：不需要额外的存储空间，仅使用 _**O**_ (1) 的额外内存。
- **在线性**：能够边接收数据边进行排序。
| 最坏表现 | 比较：**_O _**( n2 )<br/>交换：**_O _**( n2 ) |
| --- | --- |
| 最优表现 | 比较：**_O _**( n )<br/>交换：**_O _**( 1 ) |
| 平均表现 | 比较：**_O _**( n2 )<br/>交换：**_O _**( n2 ) |
| 空间复杂度 | 总计：**_O _**( n )<br />辅助：**_O _**( 1 ) |

## 2.算法分析
插入排序是一种迭代排序方法，它逐个处理输入元素，逐步形成一个已排序的输出列表。在每一步中，它从输入中提取一个元素，确定它在已排序列表中的位置，并插入到那里。这个过程会持续，直到所有输入元素都被处理完。

这种排序方法通常是在原地完成的，即通过遍历整个数组，并在其背后形成一个已排序的部分。对于数组中的每一个位置，它都会比较当前位置的值与已排序部分的最大值。如果当前值更大，它就会继续前进。如果当前值较小，它会找到这个值在已排序部分的正确位置，将所有较大的值向上移动以腾出位置，并将当前值插入。

经过 k 次迭代后，数组的前 k+1 个元素是已排序的（“+1” 是因为跳过了第一个条目）。在每一步中，输入的第一个未处理的元素被取出，并插入到已排序部分的正确位置，，从而扩展了结果。

![](https://javgo-images.oss-cn-beijing.aliyuncs.com/2023-08-31-035050.png)

其中 x 会被插入其正确的位置，将变为：

![](https://javgo-images.oss-cn-beijing.aliyuncs.com/2023-08-31-035054.png)

从上面插入 x 之后的数组可以看到，每个大于 x 的元素在与 x 比较时都被复制到右边。

> [!TIP]
>
> 对数组进行操作的插入排序最常见的变体可以描述如下：
>
> 1. 假设存在一个名为 Insert 的函数，用于将一个值插入到数组开头的排序序列中。它从已排序序列的末尾开始工作，将每个元素向右移动一个位置，直到为新元素找到合适的位置。但是，该函数具有一个副作用，那就是会覆盖数组中紧接着排序序列后的元素值。
> 2. 要执行插入排序，从数组的最左边的元素开始，并调用 Insert 函数将遇到的每个元素插入到其正确的位置。插入的有序序列存储在数组的开头，在已经检查过的索引集中。每次插入都会覆盖一个值：正在插入的值。

下面是插入排序的图形示例：

![](https://javgo-images.oss-cn-beijing.aliyuncs.com/2023-08-31-035111.gif)

> [!TIP]
>
> 上图中部分排序列表（黑色）最初仅包含列表中的第一个元素。每次迭代时，都会从 “尚未检查顺序” 输入数据中删除一个元素（红色），并将其就地插入到排序列表中。

## 3.算法实现
回顾一下，插入排序通过逐个比较和移动元素来工作。对于每个位置的元素，该算法都会找到其在已排序部分的正确位置，并将其插入。这种方法逐渐构建一个已排序的部分，从数组的左侧开始，直到整个数组都被排序。
### 3.1 基础版本
这是插入排序最基础和最直观的实现方式。当找到一个元素位置不正确时，它会立即与前一个元素交换，直到找到其正确的位置。但是由于频繁的交换操作，这个版本可能不是最高效的。
```java
/**
 * 插入排序：基本实现
 */
public class InsertionSort01 {

    /**
     * 插入排序
     * @param arr 待排序数组
     */
    public static void insertionSort(int[] arr){
        // 记录数组长度
        int len = arr.length;
        // 遍历数组，由于第一个元素默认是有序的，所以从第二个元素开始遍历
        for (int i = 1; i < len; i++) {
            // 记录当前元素索引，用于后续比较
            int j = i;

            // 如果当前元素比前一个元素小，那么就交换这两个元素（当前元素的索引需要大于 0，否则会出现数组越界）
            while (j > 0 && arr[j] < arr[j - 1]){
                // 交换当前元素和前一个元素
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;

                // 由于当前元素和前一个元素交换了位置，所以当前元素的索引也需要向前移动一位
                j--;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {5,2,4,6,1,3};
        insertionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```
### 3.2 优化版本
为了减少交换的次数，我们可以首先将当前元素存储在一个临时变量中，然后将所有比它大的元素向右移动，最后再将它插入到正确的位置。由于减少了交换操作，这个版本通常比基础版本更快。同时代码也更加简洁，因为它避免了多次交换操作。
```java
/**
 * 插入排序：将当前元素存储在临时变量中，然后将所有比它大的元素向右移动一个位置，最后将临时变量的值插入适当的位置
 */
public class InsertionSort02 {

    /**
     * 插入排序
     * @param arr 待排序数组
     */
    public static void insertionSort(int[] arr){
        // 记录数组长度
        int len = arr.length;
        // 遍历数组，由于第一个元素默认是有序的，所以从第二个元素开始遍历
        for (int i = 1; i < len; i++) {
            // 记录当前元素值，用于后续比较
            int temp = arr[i];
            // 记录当前元素的前一个元素索引，用于后续比较
            int j = i - 1;

            // 如果当前元素比前一个元素小，那么就将前一个元素向右移动一个位置（前一个元素的索引需要大于等于 0，否则会出现数组越界）
            while (j >= 0 && temp < arr[j]){
                // 将比当前元素大的元素向右移动一个位置
                arr[j + 1] = arr[j];

                // 指针向左（以排序序列）移动一位，继续比较
                j--;
            }

            // 循环结束，此时 j 为 -1 或者 arr[j] <= temp，所以将当前元素插入到 j + 1 的位置
            arr[j + 1] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = {5,2,4,6,1,3};
        insertionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```
### 3.3 递归版本
这个版本使用递归来实现插入排序，每次递归调用都会处理数组中的一个额外元素。值的注意的是，递归版本的插入排序并不是最优的实现方式。虽然它提供了一个不同的方法来实现插入排序，但它增加了额外的内存消耗，因为每次递归调用都需要在堆栈上存储额外的信息。因此，尽管它提供了一个有趣的方法来看待插入排序，但由于其效率和内存使用情况，但在实际应用中，非递归版本更为常用。这种实现方式更多地是为了教学目的，帮助学习者理解递归的概念。
```java
/**
 * 插入排序：递归实现
 */
public class InsertionSort03 {

    /**
     * 插入排序
     * @param arr 待排序数组
     * @param n 数组长度
     */
    public static void insertionSort(int[] arr, int n){
        // 递归终止条件: 当数组长度为 1 时，不需要排序，直接返回
        if (n > 0){
            // 递归调用：对 n - 1 个元素进行排序，即将最后一个元素插入到前 n - 1 个元素中
            insertionSort(arr, n - 1);

            // 记录当前元素值，用于后续比较（其实就是最后一个元素的值）
            int temp = arr[n];
            // 记录当前元素的前一个元素索引，用于后续比较
            int j = n - 1;

            // 如果当前元素比前一个元素小，那么就将前一个元素向右移动一个位置（前一个元素的索引需要大于等于 0，否则会出现数组越界）
            while (j >= 0 && temp < arr[j]){
                // 将比当前元素大的元素向右移动一个位置
                arr[j + 1] = arr[j];

                // 指针向左（以排序序列）移动一位，继续比较
                j--;
            }

            // 循环结束，此时 j 为 -1 或者 arr[j] <= temp，所以将当前元素插入到 j + 1 的位置
            arr[j + 1] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = {5,2,4,6,1,3};
        insertionSort(arr,arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
}
```
