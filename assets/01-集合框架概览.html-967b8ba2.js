import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as d,f as a}from"./app-009ef08a.js";const r={},o=a('<hr><h2 id="title-01-集合框架概览" tabindex="-1"><a class="header-anchor" href="#title-01-集合框架概览" aria-hidden="true">#</a> title: 01-集合框架概览</h2><h2 id="_1-java-的万物之容-容器" tabindex="-1"><a class="header-anchor" href="#_1-java-的万物之容-容器" aria-hidden="true">#</a> 1.Java 的万物之容：容器</h2><p>如果我们将 Java 程序比作一个超市，那么容器就像是其中的货架和篮子，可以放置各种物品。而 Java Collections Framework (JCF) 就像是我们的 “智能货架系统”，它自 JDK 1.2 起就一直为开发者们提供服务。</p><p>那么，它的优势在哪里呢？</p><ul><li><strong>省时 &amp; 易用</strong>：大大降低了编程难度，使开发更迅速。</li><li><strong>性能优化</strong>：为程序提供了更出色的运行效率。</li><li><strong>学习简便</strong>：让新手更快上手，提高学习的效率。</li><li><strong>代码复用</strong>：允许程序在多个地方更容易地重复使用代码。</li></ul><p>当我们说到 Java 容器，你可能需要注意的是：这些容器里只喜欢存放对象。对于基本数据类型，如 int 或 long，它们需要被转化为它们的对象表现形式，比如 Integer 或 Long，才能被 “收纳”。但别担心，大多数时候这种转变都是自动完成的。虽然这样可能会增加一点性能和存储的开销，但这也极大简化了我们的编程工作。</p><p>简单来说，这些容器可以分为两大家族：<code>Collection</code> 和 <code>Map</code>。<code>Collection</code> 是那些存储对象集合的 “货架”，而 <code>Map</code> 则像是一个标签明确的 “存储柜”，其中每个物品（值）都有一个与之对应的标签（键）。</p><h2 id="_2-collection-家族" tabindex="-1"><a class="header-anchor" href="#_2-collection-家族" aria-hidden="true">#</a> 2.Collection 家族</h2><h3 id="_2-1-set-独一无二的集合" tabindex="-1"><a class="header-anchor" href="#_2-1-set-独一无二的集合" aria-hidden="true">#</a> 2.1 Set：独一无二的集合</h3><p>想象一下，你正在筹办一个派对，而 <code>Set</code> 接口的实现就像是你的宾客名单，确保每个人只被邀请一次，防止重复。在这里，我们会探讨三种常见的 <code>Set</code> 实现。</p><table><thead><tr><th>实现</th><th>数据结构</th><th>描述</th></tr></thead><tbody><tr><td>HashSet</td><td>哈希表</td><td>如果你需要迅速查找，这是个好选择。但它并不保留插入的顺序，因此如果你想知道谁首先到达派对，那么这可能不是最佳选择。遍历它得到的结果是不确定的。</td></tr><tr><td>TreeSet</td><td>红黑树</td><td>当你需要有序的邀请名单时，选择它。例如，你可能想要按年龄或姓名对宾客进行排序。但在速度方面，它的查找效率不如 HashSet。</td></tr><tr><td>LinkedHashSet</td><td>哈希表 + 双链表</td><td>当你想要速度和顺序的完美结合时，这是最佳选择。它维护了元素的插入顺序，这意味着你可以知道谁首先到达，同时还享有高效的查找速度。</td></tr></tbody></table><blockquote><p>HashSet 是基于哈希表的，所以它的查找和插入效率非常高，通常为 O(1)。而 TreeSet 是基于红黑树的，它的查找和插入效率为 O(logN)。LinkedHashSet 则结合了哈希表的速度和链表的有序性。</p></blockquote><h3 id="_2-2-list-你的日常购物清单" tabindex="-1"><a class="header-anchor" href="#_2-2-list-你的日常购物清单" aria-hidden="true">#</a> 2.2 List：你的日常购物清单</h3><p>当我们去购物时，我们可能会列一个购物清单。这个清单上的物品有其特定的顺序。<code>List</code> 接口的实现就像是我们的这个购物清单，可以存放重复的元素并保持它们的插入顺序。</p><table><thead><tr><th>实现</th><th>数据结构</th><th>描述</th></tr></thead><tbody><tr><td>ArrayList</td><td>动态数组</td><td>像是我们的购物清单的草稿，它支持随机访问，这使得你可以快速查找购物清单上的任何物品。</td></tr><tr><td>Vector</td><td>动态数组</td><td>想象一下你与家人共同维护的购物清单，Vector 是线程安全的，所以你们可以同时编辑它。</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>如果你经常更改购物清单的顺序或在中间添加和删除物品，这是个好选择，它还可以用作栈、队列和双向队列。</td></tr></tbody></table><blockquote><p>动态数组如 ArrayList 和 Vector 能够很好地支持随机访问，但它们在中间插入和删除元素时可能不如 LinkedList 高效。</p></blockquote><h3 id="_2-3-queue-排队购票" tabindex="-1"><a class="header-anchor" href="#_2-3-queue-排队购票" aria-hidden="true">#</a> 2.3 Queue：排队购票</h3><p>当我们在购票点或快餐店排队时，队列是我们必须遵守的规则，先来先得。<code>Queue</code> 接口的实现确保了这一点，并提供了其他的功能。</p><table><thead><tr><th>实现</th><th>数据结构</th><th>描述</th></tr></thead><tbody><tr><td>LinkedList</td><td>双向链表</td><td>如果你在找一个简单的双向队列，这是你的首选。它是 List 的一部分，但也很适合作为队列使用。</td></tr><tr><td>PriorityQueue</td><td>堆</td><td>这就像是 VIP 通道。当你想确保某些元素（比如 VIP）优先被处理，而不仅仅是他们到达的顺序，那么你应该选择 PriorityQueue。</td></tr></tbody></table><h2 id="_3-map-从宝藏地图到导航" tabindex="-1"><a class="header-anchor" href="#_3-map-从宝藏地图到导航" aria-hidden="true">#</a> 3.Map：从宝藏地图到导航</h2><p>想象一下，我们每天都在用地图 — 从宝藏地图的神秘探索，到使用导航在城市间穿梭。在编程世界中，<code>Map</code> 接口允许我们存储键值对，就像是地点和它的说明。让我们看看 Java 为我们提供的各种 “地图”。</p><table><thead><tr><th>实现</th><th>数据结构</th><th>描述</th></tr></thead><tbody><tr><td>HashMap</td><td>哈希表</td><td>就像是你的简单的宝藏地图，你可以快速找到任何地点和它的宝藏，但是没有固定的顺序。</td></tr><tr><td>HashTable</td><td>哈希表</td><td>这是一张古老的宝藏地图，虽然它支持多个探险家同时查看，但现代工具，如ConcurrentHashMap，为我们提供了更好和更高效的线程安全性。</td></tr><tr><td>LinkedHashMap</td><td>哈希表 + 双向链表</td><td>当你既想找到宝藏，又想记住你的旅程（插入顺序或最近查看的宝藏地点），这是你的选择。</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>这是一张精致的地图，它不仅按照某种顺序（例如地点的名称）整齐地显示所有地点，还允许你快速查找任何区域的宝藏。</td></tr></tbody></table><blockquote><p>尽管 HashMap 可以快速查找，但如果我们需要有序性，例如最小到最大的键值对，TreeMap 是更好的选择。</p></blockquote><h2 id="_4-知识体系" tabindex="-1"><a class="header-anchor" href="#_4-知识体系" aria-hidden="true">#</a> 4.知识体系</h2><figure><img src="https://javgo-images.oss-cn-beijing.aliyuncs.com/2023-09-28-153426.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',26),h=[o];function i(c,n){return e(),d("div",null,h)}const p=t(r,[["render",i],["__file","01-集合框架概览.html.vue"]]);export{p as default};
